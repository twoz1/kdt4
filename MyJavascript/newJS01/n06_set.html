<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        //Array
        //문자열의 중복을 허용하지 않는 배열 정의하기
        //(조원들의 이름을 중복을 허용하지 않고 배열에 담기)
        //1) 배열 정의
        //2) 중복 확인 가능(함수로 만들기)
        //3) 배열에 자료 담기

        //1)
        // let names = [];
        // //2) unique 확인 함수 만들기
        // //  매개변수 text로 전달된 값을 배열 names의 요소들과 비교해서
        // //  동일값이 없으면 return true, 있으면 return false
        // const unique = (text) => {
        //     for (let name of names) {
        //         if(text == name) return false;
        //     }//for
        //     return true;
        // }

        // // 3) str을 names에 담기(중복없이) 
        // let str = ['조현주', '김이지', '김찬미', '김진휘' ,'김이지' ,'김찬미'];
        // for(let name of str){
        //     //중복검사 후 담기 
        //     if(unique(name) == true) names.push(name);  //==true 생략 가능.
        // }
        // // 4) 출력 확인
        // for (let name of names){
        //     console.log(`Name => ${name}`);
        // }
        // console.log(`Names.length => ${name.length}`);

// ==========================================================================

        //set과 비교 
        //str -> mySet에 담기
        //Set의 메서드 : add, delete, has, size

        // let str = ['조현주', '김이지', '김찬미', '김진휘' ,'김이지' ,'김찬미'];

        // let mySet = new Set();

        // for(let name of str){
        //     mySet.add(name);
        // }
       
        // for(name of mySet){
        //     console.log(`Name = ${name}`);
        // }

        // mySet.delete('김진휘');
        // mySet.delete('김진휘'); //없는 값 delete하는 경우
        // console.log(`mySet.has => 김진휘=${mySet.has('김진휘')}, 김이지=${mySet.has('김이지')}`);
        // console.log(`mySet.size => ${mySet.size}`);
        // console.log(`mySet 출력 => ${mySet}`)

        //set 생성과 동시에 초기화

        // let mySet2 = new Set(str);

        // for(name of mySet2){
        //     console.log(`Name = ${name}`);
        // }

        //Set 메서드 체이닝
        //처리 후 Set Type을 return 하는 메서드는 계속 .으로 연결해서 사용 가능.
        //단, delete, has 메서드는 boolean 을 return 하가 때문에 안됨.
        //그러므로 마지막에 사용하면 가능함.

        let str = ['조현주', '김이지', '김찬미', '김진휘' ,'김이지' ,'김찬미'];

        let mySet2 = new Set(str);
        mySet2.add('김이지').add('김진휘').add('김찬미').add('조현주').add('김이지').delete('김이지');

        for(name of mySet2){
            console.log(`Name2 = ${name}`);
        }

        //    forEach(CallBack함수) : 요소를 순회
        // => 이때 매개변수로 사용되는 CallBack함수 는 3개의 인수를 전달받음
        //    (현재 요소값, 현재 요소값, 현재 순회중인 set객체 자체)
        // => 배열의 forEach 메서드 Array.prototype.forEach 의 CallBack함수 의 인수는
        //    (현재 요소값, 현재 인덱스, 현재 순회중인 배열객체 자체)
        // => Map의 forEach 메서드 Map, prototype, forEach 
        //    (현재 value, 현재 key, 현재 순회 중인 map 객체 자체)

        mySet2.forEach(function(v1, v2) {
            console.log(`forEach(함수) = ${v1},${v2}`);
        });

        // let mySet = new Set(str);
        // console.log(mySet);


        
    </script>
</head>
<body>
    <pre>
        <h3>** 새로 추가된 컬렉션(collections) Set **</h3>
        => Set은 중복을 허용하지 않는 데이터(value) 들의 집합.
        => Set은 수정 가능하며, 프로그램이 실행되는 동안 값의 추가나 삭제 가능함.
          ( delete 성공시 true 를 반환하고 실패시 false 를 반환 )
        
        ** Set과 Array 의 차이점 **
        => 값이 중복되지 않습니다 ( 중복값은 저장하지 않음 )
          const mySet = new Set("abcd");
          mySet.size; // 4
          mySet.add("a");
          mySet.size; // 4
        
        => 데이터 확인이 편리하고 빠름.
          const mySet = new Set("abcd");
          const myArray = [..."abcd"];
            
          myArray.indexOf("a") !== -1 // true slow
          mySet.has("a")              // true fast   
          
        => Set은 인덱스 값으로 데이터 조회는 불가능
          myArray[0]; // "a"
          mySet[0];   // undefined
        </pre>
</body>
</html>